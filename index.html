<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>緊急コールシステム</title>
    <link rel="manifest" href="/manifest.webmanifest">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <link rel="apple-touch-icon" href="/icons/icon-192.png">
    <style>
:root {
  --color-cream-50: rgba(252, 252, 249, 1);
  --color-cream-100: rgba(255, 255, 253, 1);
  --color-gray-200: rgba(245, 245, 245, 1);
  --color-slate-500: rgba(98, 108, 113, 1);
  --color-brown-600: rgba(94, 82, 64, 1);
  --color-charcoal-700: rgba(31, 33, 33, 1);
  --color-charcoal-800: rgba(38, 40, 40, 1);
  --color-slate-900: rgba(19, 52, 59, 1);
  --color-teal-300: rgba(50, 184, 198, 1);
  --color-teal-500: rgba(33, 128, 141, 1);
  --color-teal-600: rgba(29, 116, 128, 1);
  --color-red-400: rgba(255, 84, 89, 1);
  --color-red-500: rgba(192, 21, 47, 1);
  --color-background: var(--color-cream-50);
  --color-surface: var(--color-cream-100);
  --color-text: var(--color-slate-900);
  --color-primary: var(--color-teal-500);
  --color-primary-hover: var(--color-teal-600);
  --color-border: rgba(94, 82, 64, 0.2);
  --color-card-border: rgba(94, 82, 64, 0.12);
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-background: var(--color-charcoal-700);
    --color-surface: var(--color-charcoal-800);
    --color-text: var(--color-gray-200);
    --color-primary: var(--color-teal-300);
  }
}

* { box-sizing: border-box; margin: 0; padding: 0; }
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  background: var(--color-background);
  color: var(--color-text);
  line-height: 1.6;
  padding: 20px;
}

.container { max-width: 800px; margin: 0 auto; }
.card {
  background: var(--color-surface);
  border-radius: 12px;
  padding: 24px;
  margin-bottom: 20px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

h2 { margin-bottom: 16px; }
h3 { margin-bottom: 12px; font-size: 18px; }

.btn {
  display: inline-block;
  padding: 12px 24px;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  width: 100%;
  margin-top: 12px;
}

.btn-primary {
  background: var(--color-primary);
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: var(--color-primary-hover);
}

.btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.emergency-btn {
  width: 200px;
  height: 200px;
  border-radius: 50%;
  font-size: 28px;
  background: linear-gradient(135deg, var(--color-red-400), var(--color-red-500));
  color: white;
  border: 4px solid white;
  box-shadow: 0 8px 24px rgba(192, 21, 47, 0.3);
  margin: 30px auto;
  display: block;
}

.emergency-btn:hover:not(:disabled) { transform: scale(1.05); }

.status {
  padding: 8px 16px;
  border-radius: 20px;
  display: inline-block;
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 16px;
}

.status-success { background: rgba(33, 128, 141, 0.15); color: var(--color-primary); }
.status-warning { background: rgba(168, 75, 47, 0.15); color: rgba(168, 75, 47, 1); }
.status-error { background: rgba(192, 21, 47, 0.15); color: var(--color-red-500); }

input, select {
  width: 100%;
  padding: 12px;
  border: 1px solid var(--color-border);
  border-radius: 8px;
  margin-top: 8px;
  font-size: 16px;
  background: var(--color-surface);
  color: var(--color-text);
}

label {
  display: block;
  font-weight: 600;
  margin-top: 16px;
}

.video-container {
  position: relative;
  width: 100%;
  aspect-ratio: 16/9;
  background: #000;
  border-radius: 12px;
  overflow: hidden;
  margin: 20px 0;
}

.control-btn {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: rgba(0,0,0,0.6);
  color: white;
  border: none;
  font-size: 20px;
  cursor: pointer;
}

.control-btn:hover { background: rgba(0,0,0,0.8); }
.control-btn.end { background: var(--color-red-500); }

.log-box {
  max-height: 300px;
  overflow-y: auto;
  background: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: 8px;
  padding: 12px;
  font-family: monospace;
  font-size: 13px;
}

.log-entry {
  padding: 4px 0;
  border-bottom: 1px solid var(--color-border);
}

.hidden { display: none !important; }

.info-box {
  background: rgba(33, 128, 141, 0.1);
  padding: 16px;
  border-radius: 8px;
  margin: 16px 0;
  border-left: 4px solid var(--color-primary);
}

.code-box {
  background: rgba(0,0,0,0.05);
  padding: 12px;
  border-radius: 6px;
  font-family: monospace;
  font-size: 12px;
  word-break: break-all;
  margin-top: 8px;
}

/* --- 新しいモバイル最適化ビデオ通話UI --- */

/* 通話画面のメインコンテナ */
.call-area {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: #000;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

/* ビデオコンテンツ領域 */
.video-content {
    flex: 1;
    position: relative;
    overflow: hidden;
}

/* 相手の映像 (メイン画面) */
.remote-video {
    width: 100%;
    height: 100%;
    object-fit: cover;
    background-color: #222;
}

/* 自分の映像 (右上の小窓) */
.local-video {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 100px;
    height: 75px;
    border-radius: 12px;
    border: 2px solid rgba(255, 255, 255, 0.3);
    object-fit: cover;
    background-color: #333;
    z-index: 10;
    transition: opacity 0.3s ease;
}

/* 自分の映像がOFFの時 */
.local-video.hidden {
    opacity: 0;
    pointer-events: none;
}

/* コントロールエリア（画面下部に固定） */
.call-controls {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 90px;
    background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0.3));
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 25px;
    padding: 20px;
    z-index: 20;
}

/* 個別のコントロールボタン */
.control-btn {
    width: 56px;
    height: 56px;
    border-radius: 50%;
    border: none;
    font-size: 22px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* 通常のボタン（マイク、カメラ、自分映像ON/OFF） */
.control-btn.normal {
    background-color: rgba(255, 255, 255, 0.15);
    color: white;
    backdrop-filter: blur(10px);
}

.control-btn.normal:hover {
    background-color: rgba(255, 255, 255, 0.25);
    transform: scale(1.05);
}

/* OFF状態のボタン */
.control-btn.off {
    background-color: #dc3545;
    color: white;
}

.control-btn.off:hover {
    background-color: #c82333;
    transform: scale(1.05);
}

/* 通話終了ボタン（赤色、大きめで目立つ） */
.control-btn.end-call {
    background-color: #dc3545;
    color: white;
    width: 64px;
    height: 64px;
    font-size: 26px;
}

.control-btn.end-call:hover {
    background-color: #c82333;
    transform: scale(1.1);
}

/* 状態表示用のテキスト */
.status-info {
    position: absolute;
    top: 20px;
    left: 20px;
    background-color: rgba(0,0,0,0.6);
    color: white;
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 14px;
    z-index: 15;
}


    </style>
</head>
<body>
    <div class="container" id="app">
        <!-- セットアップ画面 -->
        <div id="setupScreen">
            <div class="card">
                <h2>🚨 緊急コールシステム</h2>
                
                <div class="info-box">
                    <strong>システムの特徴</strong>
                    <ul style="margin-top: 8px; margin-left: 20px;">
                        <li>✓ あなたの操作でのみ通知発動</li>
                        <li>✓ VAPID標準プロトコル使用（iOS Safari対応）</li>
                        <li>✓ PeerJS WebRTCシグナリング</li>
                        <li>✓ 通話セッションID自動生成</li>
                        <li>✓ 認証コードによる受信者登録</li>
                        <li>✓ オートアンサー機能</li>
                    </ul>
                </div>

                <label>ユーザータイプ:</label>
                <select id="userType">
                    <option value="">選択してください</option>
                    <option value="sender">発信者（緊急ボタンを押す側）</option>
                    <option value="receiver">受信者（通知を受け取る側）</option>
                </select>

                <button class="btn btn-primary" onclick="proceedToSetup()">次へ</button>
            </div>
        </div>

        <!-- 新しいログイン画面 -->
        <div id="loginScreen" class="hidden">
            <div class="card">
                <h2>📞 発信者ログイン</h2>
                <p>発信を行うには、共有されたパスワードを入力してください。</p>
                <label for="password">パスワード:</label>
                <input type="password" id="password" placeholder="パスワード">
                <button class="btn btn-primary" onclick="handleLogin()">ログイン</button>
            </div>
        </div>

        <!-- 発信者セットアップ -->
        <div id="senderSetup" class="hidden">
            <div class="card">
                <h2>📞 発信者セットアップ</h2>
                
                <label>受信者ID:</label>
                <input type="text" id="receiverId" placeholder="例: parent_A">

                <label>サーバーURL（通知送信用）:</label>
                <input type="text" id="serverUrl" placeholder="https://your-server.onrender.com" value="https://emergency-call-server.onrender.com">

                <div class="info-box" style="margin-top: 20px;">
                    <strong>💡 ヒント</strong>
                    <p style="margin-top: 8px;">受信者IDは、受信者が登録時に使用したIDと同じものを入力してください。</p>
                </div>

                <button class="btn btn-primary" onclick="initSender()">発信者モード開始</button>
            </div>
        </div>

        <!-- 受信者セットアップ -->
        <div id="receiverSetup" class="hidden">
            <div class="card">
                <h2>📱 受信者セットアップ</h2>
                
                <label>受信者ID（あなたのID）:</label>
                <input type="text" id="myReceiverId" placeholder="例: parent_A">

                <label>認証コード（発信者から受け取った6桁）:</label>
                <input type="text" id="authCode" placeholder="例: 582937" maxlength="6">

                <label>サーバーURL:</label>
                <input type="text" id="receiverServerUrl" placeholder="https://your-server.onrender.com" value="https://emergency-call-server.onrender.com">

                <div class="info-box" style="margin-top: 20px;">
                    <strong>🔒 セキュリティ</strong>
                    <p style="margin-top: 8px;">認証コードは発信者から別の安全な方法（電話など）で受け取ってください。このコードにより、あなただけがこのIDに登録できます。</p>
                </div>

                <button class="btn btn-primary" onclick="initReceiver()">受信者モード開始</button>
            </div>
        </div>

        <!-- 発信者画面 -->
        <div id="senderScreen" class="hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h2 style="margin-bottom: 0;">📞 発信者モード</h2>
                    <button class="btn" style="width: auto; margin-top: 0;" onclick="goBackToHome()">ユーザー変更</button>
                </div>
                <div id="senderStatus" class="status status-warning">初期化中...</div>

                <button class="emergency-btn" id="callBtn" onclick="makeEmergencyCall()" disabled>
                    緊急<br>コール
                </button>

                <div id="senderCallArea" class="hidden">
                    <div class="video-container">
                        <div class="call-area">
                            <!-- ステータス表示 -->
                            <div class="status-info">通話中</div>
                            
                            <!-- ビデオコンテンツ -->
                            <div class="video-content">
                                <video id="senderRemoteVideo" class="remote-video" autoplay playsinline></video>
                                <video id="senderLocalVideo" class="local-video" autoplay muted playsinline></video>
                            </div>
                            
                            <!-- コントロールボタン -->
                            <div class="call-controls">
                                <button id="senderMicBtn" class="control-btn normal" onclick="toggleMute('sender')" title="マイク">🎤</button>
                                <button id="senderCameraBtn" class="control-btn normal" onclick="toggleCamera('sender')" title="カメラ">📷</button>
                                <button id="senderSelfViewBtn" class="control-btn normal" onclick="toggleSelfView('sender')" title="自分の映像">👁️</button>
                                <button class="control-btn end-call" onclick="endCall('sender')" title="通話終了">📞</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 受信者画面 -->
        <div id="receiverScreen" class="hidden">
            <div class="card">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                    <h2 style="margin-bottom: 0;">📱 受信者モード</h2>
                    <button class="btn" style="width: auto; margin-top: 0;" onclick="goBackToHome()">ユーザー変更</button>
                </div>
                <div id="receiverStatus" class="status status-warning">初期化中...</div>
                
                <div id="subscriptionInfo" class="hidden">
                    <h3>登録情報</h3>
                    <p>プッシュ通知の購読が完了しました。</p>
                    <div class="code-box" id="subscriptionData"></div>
                </div>

                <div id="receiverCallArea" class="hidden">
                    <div class="video-container">
                        <div class="call-area">
                            <!-- ステータス表示 -->
                            <div class="status-info">通話中</div>
                            
                            <!-- ビデオコンテンツ -->
                            <div class="video-content">
                                <video id="receiverRemoteVideo" class="remote-video" autoplay playsinline></video>
                                <video id="receiverLocalVideo" class="local-video" autoplay muted playsinline></video>
                            </div>
                            
                            <!-- コントロールボタン -->
                            <div class="call-controls">
                                <button id="receiverMicBtn" class="control-btn normal" onclick="toggleMute('receiver')" title="マイク">🎤</button>
                                <button id="receiverCameraBtn" class="control-btn normal" onclick="toggleCamera('receiver')" title="カメラ">📷</button>
                                <button id="receiverSelfViewBtn" class="control-btn normal" onclick="toggleSelfView('receiver')" title="自分の映像">👁️</button>
                                <button class="control-btn end-call" onclick="endCall('receiver')" title="通話終了">📞</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ログ -->
        <div class="card">
            <h3>📋 システムログ</h3>
            <div class="log-box" id="logBox"></div>
        </div>
    </div>

    <!-- PeerJS -->
    <script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>

    <script>
// グローバル変数
let userType = null;
let config = {
    receiverId: null,
    serverUrl: null,
    authCode: null
};
let peer = null;
let currentCall = null;
let localStream = null;
let pushSubscription = null;
let sessionId = null;
let sessionToken = null; // 一時トークンを保持

// ログ関数
function log(msg, type = 'info') {
    const logBox = document.getElementById('logBox');
    const time = new Date().toLocaleTimeString('ja-JP');
    const entry = document.createElement('div');
    entry.className = 'log-entry';
    entry.textContent = `[${time}] ${msg}`;
    logBox.appendChild(entry);
    logBox.scrollTop = logBox.scrollHeight;
    console.log(`[${type}] ${msg}`);
}

// セットアップ進行
function proceedToSetup() {
    const type = document.getElementById('userType').value;
    if (!type) {
        alert('ユーザータイプを選択してください');
        return;
    }
    
    userType = type;
    document.getElementById('setupScreen').classList.add('hidden');
    
    if (type === 'sender') {
        // 発信者の場合は、まずログイン画面を表示
        document.getElementById('loginScreen').classList.remove('hidden');
    } else {
        document.getElementById('receiverSetup').classList.remove('hidden');
    }
}

// --- 新しいhandleLogin関数 ---
async function handleLogin() {
    const password = document.getElementById('password').value;
    const serverUrl = document.getElementById('serverUrl').value || document.getElementById('receiverServerUrl').value;
    
    if (!password || !serverUrl) {
        alert('パスワードとサーバーURLを入力してください。');
        return;
    }

    try {
        const response = await fetch(`${serverUrl}/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ password: password })
        });
        
        const result = await response.json();
        
        if (result.success) {
            log('ログイン成功');
            sessionToken = result.token; // トークンを保存
            
            // ログイン画面を隠し、発信者セットアップ画面を表示
            document.getElementById('loginScreen').classList.add('hidden');
            document.getElementById('senderSetup').classList.remove('hidden');
        } else {
            throw new Error(result.error || 'ログインに失敗しました。');
        }
    } catch (error) {
        log(`ログインエラー: ${error.message}`, 'error');
        alert('ログインに失敗しました。パスワードを確認してください。');
    }
}

// 発信者初期化
async function initSender() {
    // UIから値を取得して保存
    saveConfig();
    
    if (!config.receiverId || !config.serverUrl) {
        alert('すべての項目を入力してください');
        return;
    }
    
    document.getElementById('senderSetup').classList.add('hidden');
    document.getElementById('senderScreen').classList.remove('hidden');
    
    log('発信者モードを初期化中...');

    // PeerJS接続を管理する関数を定義
    function connectToPeerJS() {
        if (peer && !peer.destroyed) {
            log('既存のPeer接続を破棄します。');
            peer.destroy();
        }

        const peerId = 'sender_' + Date.now();
        log(`PeerJSサーバーに接続試行... ID: ${peerId}`);
        document.getElementById('senderStatus').textContent = 'シグナリングサーバー接続中...';
        document.getElementById('senderStatus').className = 'status status-warning';
        document.getElementById('callBtn').disabled = true;

        // PeerJS初期化（ハートビートと再接続ロジックを追加）
        peer = new Peer(peerId, {
            host: '0.peerjs.com',
            secure: true,
            port: 443,
            pingInterval: 5000 // 5秒ごとにハートビートを送信して接続を維持
        });
        
        peer.on('open', (id) => {
            log(`✅ PeerJS接続成功: ${id}`);
            document.getElementById('senderStatus').textContent = '準備完了';
            document.getElementById('senderStatus').className = 'status status-success';
            document.getElementById('callBtn').disabled = false;
        });
        
        // サーバーとの接続が一時的に切断された場合
        peer.on('disconnected', () => {
            log('PeerJSサーバーとの接続が切れました。自動再接続を試みます...', 'warning');
            document.getElementById('senderStatus').textContent = '再接続中...';
            document.getElementById('senderStatus').className = 'status status-warning';
            // PeerJSは内部で自動的に再接続を試みます
        });

        // 接続が完全に閉じた場合（destroyされた時など）
        peer.on('close', () => {
            log('PeerJS接続が完全に閉じました。', 'error');
        });

        // 何らかのエラーが発生した場合
        peer.on('error', (err) => {
            log(`PeerJSエラー: ${err.message}`, 'error');
            document.getElementById('senderStatus').textContent = '接続エラー';
            document.getElementById('senderStatus').className = 'status status-error';
            
            // エラータイプによって再接続を試みる
            if (err.type === 'network' || err.type === 'server-error') {
                log('接続エラーのため、5秒後に再接続します。');
                setTimeout(connectToPeerJS, 5000);
            } else if (err.type !== 'peer-unavailable') {
                 log('回復不能なエラーが発生しました。ページの再読み込みが必要な場合があります。');
            }
        });
        
        // 着信処理は変わりません
        peer.on('call', (call) => {
            // 条件分岐を削除し、常に着信に応答する
            log('着信を受信、応答します。');
            
            // localStreamがnullの場合でも、そのまま渡すことで受信専用の接続が確立される
            answerIncomingCall(call, localStream);
        });
    }

    // 初回の接続を開始
    connectToPeerJS();
}


// 受信者初期化
async function initReceiver() {
    // UIから値を取得して保存
    saveConfig();
    // authCodeは一時的なものなので保存しない
    config.authCode = document.getElementById('authCode').value;
    
    if (!config.receiverId || !config.authCode || !config.serverUrl) {
        alert('すべての項目を入力してください');
        return;
    }
    
    if (config.authCode.length !== 6) {
        alert('認証コードは6桁で入力してください');
        return;
    }
    
    document.getElementById('receiverSetup').classList.add('hidden');
    document.getElementById('receiverScreen').classList.remove('hidden');
    
    log('受信者モードを初期化中...');
    
    // プッシュ通知購読
    await subscribeToPush();
    
    // URLパラメータから自動応答チェック
    checkAutoAnswer();
}

// Service Worker登録
async function registerServiceWorker() {
    try {
        if (!('serviceWorker' in navigator)) {
            throw new Error('このブラウザはService Workerをサポートしていません。');
        }

        log('Service Workerを登録中...');
        
        // 物理ファイル '/sw.js' を登録
        const registration = await navigator.serviceWorker.register('/sw.js');
        
        log('✅ Service Worker登録完了');
        return registration;
        
    } catch (error) {
        log(`Service Workerエラー: ${error.message}`, 'error');
        // エラーを画面にも表示
        document.getElementById('receiverStatus').textContent = `登録失敗: ${error.message}`;
        document.getElementById('receiverStatus').className = 'status status-error';
        throw error; // エラーを投げて処理を中断
    }
}


// プッシュ通知購読
async function subscribeToPush() {
    try {
        log('プッシュ通知を購読中...');

        // 機能判定（iOSは特に厳しい要件があるため詳細にチェック）
        if (!('serviceWorker' in navigator)) {
            throw new Error('Service Worker非対応です。');
        }
        if (!('PushManager' in window)) {
            // iOSでホーム画面から起動されているかどうかのヒント
            const isStandalone = window.navigator.standalone || window.matchMedia('(display-mode: standalone)').matches;
            if (/iP(ad|hone|od)/.test(navigator.userAgent) && !isStandalone) {
                 throw new Error('Push API非対応です。iOSでは、まずホーム画面に追加してから、そのアイコンからアプリを起動してください。');
            }
            throw new Error('Push API非対応環境です（iOSは16.4+のホーム画面Webアプリが必要）');
        }
        if (typeof Notification === 'undefined') {
            throw new Error('Notification API非対応です。iOSは16.4以上でホーム画面に追加後、再起動してください。');
        }
        
        // 通知権限リクエスト
        const permission = await Notification.requestPermission();
        if (permission !== 'granted') {
            throw new Error('通知権限が拒否されました');
        }
        
        const registration = await navigator.serviceWorker.ready;

        
        // VAPIDキー（実際の実装ではサーバーから取得）
        const vapidPublicKey = 'BDOUeyD14YynH1b_rvrpaU611y2CMUFqj3plJWedwDK5G9ZjWsYWDtsm2oxTJAkikxG2RSi7MtzBMlNuIrO6UPo';
        
        const subscription = await registration.pushManager.subscribe({
            userVisibleOnly: true,
            applicationServerKey: urlBase64ToUint8Array(vapidPublicKey)
        });
        
        pushSubscription = subscription;
        log('プッシュ購読完了');
        
        // サーバーに登録
        await registerToServer(subscription);
        
    } catch (error) {
        log(`プッシュ購読エラー: ${error.message}`, 'error');
    }
}

// サーバーに購読情報を登録
async function registerToServer(subscription) {
    try {
        log('サーバーに登録中...');
        
        const response = await fetch(`${config.serverUrl}/register`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                receiverId: config.receiverId,
                authCode: config.authCode,
                subscription: subscription
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            log('✅ サーバー登録成功', 'success');
            document.getElementById('receiverStatus').textContent = '通知待機中';
            document.getElementById('receiverStatus').className = 'status status-success';
            
            document.getElementById('subscriptionInfo').classList.remove('hidden');
            document.getElementById('subscriptionData').textContent = 
                `受信者ID: ${config.receiverId}\n登録日時: ${new Date().toLocaleString('ja-JP')}`;
        } else {
            throw new Error(result.error || '登録失敗');
        }
        
    } catch (error) {
        log(`サーバー登録エラー: ${error.message}`, 'error');
        alert('登録に失敗しました。認証コードを確認してください。');
    }
}

// ---ここから追加---

// 設定をlocalStorageに保存する
function saveConfig() {
    // 現在のUIフィールドから最新の値を取得してconfigオブジェクトを更新
    // userTypeに応じて保存する内容を分ける
    if (userType === 'sender') {
        config.receiverId = document.getElementById('receiverId').value;
        config.serverUrl = document.getElementById('serverUrl').value;
    } else if (userType === 'receiver') {
        config.receiverId = document.getElementById('myReceiverId').value;
        config.serverUrl = document.getElementById('receiverServerUrl').value;
    }
    
    // userTypeも保存対象に含める
    const configToSave = {
        userType: userType,
        receiverId: config.receiverId,
        serverUrl: config.serverUrl,
    };

    localStorage.setItem('emergencyCallConfig', JSON.stringify(configToSave));
    log('設定を保存しました。');
}

// localStorageから設定を読み込む
function loadSavedConfig() {
    const savedConfig = localStorage.getItem('emergencyCallConfig');
    if (savedConfig) {
        const parsedConfig = JSON.parse(savedConfig);
        config = { ...config, ...parsedConfig }; // グローバルconfigを更新
        
        // UIのフィールドにも値を反映させる
        document.getElementById('userType').value = config.userType || '';
        document.getElementById('receiverId').value = config.receiverId || '';
        document.getElementById('myReceiverId').value = config.receiverId || '';
        document.getElementById('serverUrl').value = config.serverUrl || '';
        document.getElementById('receiverServerUrl').value = config.serverUrl || '';

        log('保存済み設定を読み込みました。');
        return true;
    }
    log('保存された設定はありません。');
    return false;
}

//　前提条件が満たされるまでボタンを不可視/非活性にする。条件成立と同時に有効化。
const gate = {
  swReady: false,
  pushReady: false,
  idReady: false,
  serverReady: false
};
function updateCallGate() {
  const allOk = gate.swReady && gate.pushReady && gate.idReady && gate.serverReady;
  const btn = document.getElementById('callBtn');
  const hint = document.getElementById('callGateHint');
  if (btn) {
    btn.disabled = !allOk;
    btn.style.opacity = allOk ? '1' : '0.5';
    btn.style.pointerEvents = allOk ? 'auto' : 'none';
    btn.style.display = allOk ? 'inline-flex' : 'none'; // 完全に隠す場合
  }
  if (hint) {
    hint.textContent = allOk ? '発信可能です' : '準備中…';
  }
}
async function runStartupChecks() {
  // 1) SW
  try {
    await navigator.serviceWorker.ready;
    gate.swReady = true;
  } catch { gate.swReady = false; }
  updateCallGate();

  // 2) Push購読
  try {
    const reg = await navigator.serviceWorker.ready;
    let sub = await reg.pushManager.getSubscription(); // 既存購読確認
    if (!sub) {
      // 購読実行（VAPID公開鍵は既存の方法で）
      sub = await reg.pushManager.subscribe({ userVisibleOnly: true, applicationServerKey: vapidUint8Key });
      // サーバーへ登録（receiverIdと紐付け）
      await fetch(`${config.serverUrl}/register`, { method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ receiverId: config.receiverId, subscription: sub }) });
    }
    gate.pushReady = !!sub;
  } catch {
    gate.pushReady = false;
  }
  updateCallGate();

  // 3) ID/URL
  gate.idReady = !!(config.receiverId && config.receiverId.trim()) && !!(config.serverUrl && config.serverUrl.trim());
  updateCallGate();

  // 4) サーバー到達性
  try {
    const r = await fetch(`${config.serverUrl}/health`, { cache:'no-store' });
    gate.serverReady = r.ok;
  } catch {
    gate.serverReady = false;
  }
  updateCallGate();

  // 任意: 権限状態をUI表示のみ（ゲートには影響させない）
  if (navigator.permissions) {
    try {
      const mic = await navigator.permissions.query({ name: 'microphone' });
      const cam = await navigator.permissions.query({ name: 'camera' });
      // mic.state / cam.state をUIに表示（granted / denied / prompt）
    } catch {}
  }
}
window.addEventListener('load', runStartupChecks);

// 入力項目変化で即ゲート更新:
document.getElementById('receiverId')?.addEventListener('input', e => {
  config.receiverId = e.target.value; gate.idReady = !!config.receiverId.trim(); updateCallGate();
});
document.getElementById('serverUrl')?.addEventListener('input', e => {
  config.serverUrl = e.target.value; gate.idReady = !!config.receiverId?.trim(); updateCallGate();
});

// 接続自己回復
function attachPcStateWatch(pc) {
  pc.addEventListener('iceconnectionstatechange', () => {
    const s = pc.iceConnectionState; // new/checking/connected/completed/disconnected/failed/closed
    if (s === 'disconnected' || s === 'failed') {
      try { pc.restartIce(); } catch {}
    }
  });
}


// Base64変換
function urlBase64ToUint8Array(base64String) {
    const padding = '='.repeat((4 - base64String.length % 4) % 4);
    const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
    const rawData = window.atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; ++i) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

// 緊急コール発信
async function makeEmergencyCall() {
    log('緊急コールを開始...');
    document.getElementById('callBtn').disabled = true;

    // --- 診断ログの追加 ---
    try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        log('利用可能なメディアデバイス:');
        devices.forEach(device => {
            log(`- ${device.kind}: ${device.label || 'label not available'} (ID: ${device.deviceId.substring(0,10)}...)`);
        });
        if (!devices.some(d => d.kind === 'videoinput')) log('警告: カメラが見つかりません。', 'warning');
        if (!devices.some(d => d.kind === 'audioinput')) log('警告: マイクが見つかりません。', 'warning');
    } catch (e) {
        log(`デバイスリストの取得に失敗: ${e.message}`, 'error');
    }
    // --------------------

    // --- 事前クリーンアップ処理の追加 ---
    // 万が一、古いストリームが残っていた場合に停止させる
    if (localStream) {
        log('古いメディアストリームが残っているため、強制的に停止します。', 'warning');
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
    }
    // ---------------------------------

    try {
        // セッションID生成
        sessionId = 'emergency_' + Date.now();
        log(`セッションID: ${sessionId}`);
        

        // メディア取得を柔軟に変更
        log('カメラとマイクへのアクセスを試みます...');
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            log('✅ カメラ・マイクにアクセス成功');
        } catch (streamError) {
            log(`メディアデバイスの取得に失敗: ${streamError.name} - ${streamError.message}`, 'warning');
            log('音声のみでの接続を試みます...');
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: false,
                    audio: true
                });
                log('✅ マイクのみアクセス成功');
            } catch (audioError) {
                log('マイクの取得にも失敗しました。視聴のみで接続します。', 'warning');
                // この場合、localStreamはnullのまま
                localStream = null;
            }
        }

        // UIの更新 (localStreamが存在する場合のみ)
        if (localStream) {
            document.getElementById('senderLocalVideo').srcObject = localStream;
        }
        document.getElementById('senderCallArea').classList.remove('hidden');
            
        // プッシュ通知送信
        await sendPushNotification();
        
        // PeerJS通話待機（受信者からの接続を待つ）
        log('受信者の接続を待機中...');
        
    } catch (error) {
        log(`発信エラー: ${error.name} - ${error.message}`, 'error');
        // エラー発生時は確実にリソースを解放し、UIを元に戻す
        endCall('sender'); 
        alert(`カメラまたはマイクの取得に失敗しました。他のアプリで使用中でないか確認してください。\nエラー: ${error.name}`);
    }
}

// プッシュ通知送信
async function sendPushNotification() {
    if (!sessionToken) {
        alert('ログインセッションが無効です。再度ログインしてください。');
        goBackToHome(); // 初期画面に戻す
        return;
    }
    
    try {
        log('プッシュ通知を送信中...');
        
        const response = await fetch(`${config.serverUrl}/send-notification`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${sessionToken}` // --- トークンをヘッダーに追加 ---
            },
            body: JSON.stringify({
                receiverId: config.receiverId,
                sessionId: sessionId,
                senderId: peer.id,
                title: '🚨 緊急コール',
                body: '緊急通話が開始されました。タップして応答してください。'
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            log('✅ プッシュ通知送信成功', 'success');
        } else {
            throw new Error(result.error || '通知送信失敗');
        }
        
    } catch (error) {
        log(`通知送信エラー: ${error.message}`, 'error');
    }
}

// 自動応答チェック
function checkAutoAnswer() {
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('autoAnswer') === 'true') {
        const sessionId = urlParams.get('sessionId');
        log(`自動応答モード: ${sessionId}`);
        setTimeout(() => autoAnswerCall(sessionId), 1000);
    }
}

// 自動応答
async function autoAnswerCall(sessionId, senderId) {
    try {
        log('自動応答を開始...');

        // メディア取得を柔軟に変更
        log('カメラとマイクへのアクセスを試みます...');
        try {
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            log('✅ カメラ・マイクにアクセス成功');
        } catch (streamError) {
            log(`メディアデバイスの取得に失敗: ${streamError.name} - ${streamError.message}`, 'warning');
            log('音声のみでの接続を試みます...');
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: false,
                    audio: true
                });
                log('✅ マイクのみアクセス成功');
            } catch (audioError) {
                log('マイクの取得にも失敗しました。視聴のみで接続します。', 'warning');
                localStream = null;
            }
        }

        // UIの更新
        if (localStream) {
            document.getElementById('receiverLocalVideo').srcObject = localStream;
        }
        document.getElementById('receiverCallArea').classList.remove('hidden');

        
        // PeerJS接続（引数で受け取ったsenderIdを使用）
        log(`発信者(${senderId})に接続中...`);
        
        const receiverPeer = new Peer('receiver_' + Date.now(), {
            host: '0.peerjs.com',
            secure: true,
            port: 443,
            // ICEサーバー設定も適用
            config: { iceServers: await getIceServers() } 
        });
        
        receiverPeer.on('open', () => {
            log('PeerJS接続完了、発信者を呼び出し中...');
            const call = receiverPeer.call(senderId, localStream);
            
            // 生成直後にPCを監視
            const pc = call?.peerConnection || call?._pc || call?._peerConnection;
            if (pc) attachPcStateWatch(pc);

            if (!call) {
                log('発信者への接続開始に失敗しました。', 'error');
                return;
            }

            currentCall = call;
            
            call.on('stream', (remoteStream) => {
                log('発信者の映像を受信しました');
                document.getElementById('receiverRemoteVideo').srcObject = remoteStream;
                document.getElementById('receiverStatus').textContent = '通話中';
                document.getElementById('receiverStatus').className = 'status status-success';
            });

            call.on('close', () => {
                log('通話が終了しました。');
                endCall('receiver');
            });

            call.on('error', (err) => {
                log(`通話エラー: ${err.message}`, 'error');
                // エラー発生時にも必ず通話を終了する
                endCall('receiver');
            });
        });

        receiverPeer.on('error', (err) => {
            log(`受信者Peerエラー: ${err.message}`, 'error');
        });
        
    } catch (error) {
        log(`自動応答エラー: ${error.message}`, 'error');
        document.getElementById('receiverStatus').textContent = '応答失敗';
        document.getElementById('receiverStatus').className = 'status status-error';
    }
}


// 着信応答（発信者側）
function answerIncomingCall(call, stream) { // 引数にstreamを追加
    log('着信に応答します...');
    currentCall = call;
    
    call.answer(stream);
    
    // ここで内部のPCを取得して監視を付与
    const pc = call.peerConnection || call._pc || call._peerConnection;
    if (pc) attachPcStateWatch(pc); // ← このタイミングがベスト
    
    call.on('stream', (remoteStream) => {
        log('受信者の映像を受信');
        document.getElementById('senderRemoteVideo').srcObject = remoteStream;
    });
    
    call.on('close', () => {
        log('通話が終了しました');
        endCall('sender');
    });
}

// マイクのミュート/アンミュート
function toggleMute(mode) {
    if (localStream) {
        const audioTracks = localStream.getAudioTracks();
        if (audioTracks.length > 0) {
            const isEnabled = audioTracks[0].enabled;
            audioTracks[0].enabled = !isEnabled;
            
            const btn = document.getElementById(mode + 'MicBtn');
            if (!isEnabled) {
                btn.classList.remove('off');
                btn.classList.add('normal');
                btn.textContent = '🎤';
                log('マイクON');
            } else {
                btn.classList.remove('normal');
                btn.classList.add('off');
                btn.textContent = '🔇';
                log('マイクOFF');
            }
        }
    }
}

// カメラのON/OFF
function toggleCamera(mode) {
    if (localStream) {
        const videoTracks = localStream.getVideoTracks();
        if (videoTracks.length > 0) {
            const isEnabled = videoTracks[0].enabled;
            videoTracks[0].enabled = !isEnabled;
            
            const btn = document.getElementById(mode + 'CameraBtn');
            if (!isEnabled) {
                btn.classList.remove('off');
                btn.classList.add('normal');
                btn.textContent = '📷';
                log('カメラON');
            } else {
                btn.classList.remove('normal');
                btn.classList.add('off');
                btn.textContent = '📵';
                log('カメラOFF');
            }
        }
    }
}

// 自分の映像表示のON/OFF
function toggleSelfView(mode) {
    const localVideo = document.getElementById(mode + 'LocalVideo');
    const btn = document.getElementById(mode + 'SelfViewBtn');
    
    if (localVideo.classList.contains('hidden')) {
        localVideo.classList.remove('hidden');
        btn.classList.remove('off');
        btn.classList.add('normal');
        btn.textContent = '👁️';
        log('自分の映像表示ON');
    } else {
        localVideo.classList.add('hidden');
        btn.classList.remove('normal');
        btn.classList.add('off');
        btn.textContent = '🙈';
        log('自分の映像表示OFF');
    }
}

// 通話終了
function endCall(mode) {
    log('通話を終了/クリーンアップ処理を開始します...');

    // 1. PeerJSの接続を閉じる
    if (currentCall) {
        if (!currentCall.open) {
            log('通話接続は既に閉じています。');
        } else {
            currentCall.close();
            log('PeerJSの通話接続を閉じました。');
        }
        currentCall = null;
    }

    // 2. ローカルのメディアストリーム（カメラ・マイク）を完全に停止
    if (localStream) {
        localStream.getTracks().forEach(track => {
            track.stop(); // 各トラックを停止
        });
        localStream = null;
        log('ローカルのメディアストリームを停止しました。');
    }

    // 3. ビデオ要素のソースをクリア
    // senderとreceiver両方の要素をクリア対象にする
    ['sender', 'receiver'].forEach(role => {
        const localVideoEl = document.getElementById(`${role}LocalVideo`);
        const remoteVideoEl = document.getElementById(`${role}RemoteVideo`);
        if (localVideoEl && localVideoEl.srcObject) localVideoEl.srcObject = null;
        if (remoteVideoEl && remoteVideoEl.srcObject) remoteVideoEl.srcObject = null;
    });
    log('全てのビデオ要素をクリアしました。');

    // 4. UIをリセット
    if (mode === 'sender') {
        document.getElementById('senderCallArea').classList.add('hidden');
        // 発信ボタンを再度有効化
        const callBtn = document.getElementById('callBtn');
        if (callBtn) callBtn.disabled = false;
    } else {
        document.getElementById('receiverCallArea').classList.add('hidden');
        // 必要に応じて受信者側のUIもリセット
    }
    
    log('✅ 通話が正常に終了しました。');
}

function goBackToHome() {
    log('初期画面に戻ります...');

    // 1. 進行中の通話とメディアストリームを完全に終了させる
    // userTypeが設定されていれば、対応するモードでendCallを呼ぶ
    if (userType) {
        endCall(userType);
    }
    
    // 2. PeerJSオブジェクトが残っていれば破棄する
    if (peer && !peer.destroyed) {
        peer.destroy();
        peer = null;
        log('PeerJSオブジェクトを破棄しました。');
    }

    // 3. グローバル変数を初期状態にリセット
    config = { receiverId: null, serverUrl: null, authCode: null };
    sessionId = null;
    pushSubscription = null;
    // userTypeは最後にリセット
    
    // 4. UIを初期画面に戻す
    document.getElementById('senderScreen').classList.add('hidden');
    document.getElementById('receiverScreen').classList.add('hidden');
    document.getElementById('senderSetup').classList.add('hidden');
    document.getElementById('receiverSetup').classList.add('hidden');
    document.getElementById('setupScreen').classList.remove('hidden');

    // userTypeをリセット
    userType = null;
    document.getElementById('userType').value = '';

    log('✅ 初期画面に戻りました。');
}


// ICEサーバー設定の取得フック（現状はSTUNのみ返却）
async function getIceServers() {
    try {
        // 将来: サーバの /ice-config から取得（APIキー等で保護）
        // const res = await fetch(`${config.serverUrl}/ice-config`, { headers: { 'X-API-Key': '...' }});
        // const data = await res.json();
        // return data.iceServers;

        // 現在はSTUNのみ（IPv6前提のシンプル構成）
        return [{ urls: 'stun:stun.l.google.com:19302' }];
    } catch (e) {
        log(`ICE設定取得エラー: ${e.message}`, 'error');
        return [{ urls: 'stun:stun.l.google.com:19302' }];
    }
}

// 初期化
log('緊急コールシステムが読み込まれました');

// ページ読み込み時にService Workerを登録する
// これにより、PWAとしてホーム画面に追加される前にブラウザがプッシュ機能を認識できる
// ページ読み込み時のメイン処理
window.addEventListener('load', async () => {
    log('緊急コールシステムが起動しました。');

    // まずService Workerを登録
    if ('serviceWorker' in navigator) {
        await registerServiceWorker().catch(err => {
            log('初期Service Worker登録エラー: ' + err.message, 'error');
        });
    } else {
        log('Service Worker非対応ブラウザです', 'warning');
    }
    
    // URLパラメータをチェックして自動応答フローに入るか判断
    const urlParams = new URLSearchParams(window.location.search);
    const isAutoAnswer = urlParams.get('autoAnswer') === 'true';
    const incomingSessionId = urlParams.get('sessionId');
    const incomingSenderId = urlParams.get('senderId');

    // 保存済み設定を読み込んでUIに反映
    const hasSavedConfig = loadSavedConfig();

    if (isAutoAnswer && incomingSessionId && incomingSenderId) {
        log(`自動応答モードを検出: SessionID=${incomingSessionId}, SenderID=${incomingSenderId}`);
        
        if (hasSavedConfig) {           
            // セットアップ画面を飛ばして受信者画面を表示
            document.getElementById('setupScreen').classList.add('hidden');
            document.getElementById('senderSetup').classList.add('hidden');
            document.getElementById('receiverSetup').classList.add('hidden');
            document.getElementById('receiverScreen').classList.remove('hidden');
            document.getElementById('receiverStatus').textContent = '着信に応答中...';
            document.getElementById('receiverStatus').className = 'status status-warning';
         
            // 少し遅延させてから自動応答を開始
            setTimeout(() => autoAnswerCall(incomingSessionId, incomingSenderId), 500);
        } else {
            log('自動応答が必要ですが、保存された設定が見つかりません。セットアップからやり直してください。', 'error');
            alert('初期設定が完了していません。一度受信者として登録を完了してください。');
        }
    } 
    // 通常起動時はloadSavedConfigによってUIが復元されているので、ユーザーの操作を待つ
});

    </script>
</body>
</html>
